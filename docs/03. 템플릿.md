# 03. 템플릿
## 예외처리 기능을 갖춘 DAO
- 예외처리 deleteAll()
``` java 
// 예외 발생 처리
public void deleteAll() throws SQLException, ClassNotFoundException {
    Connection c = null;
    PreparedStatement ps = null;

    try {
        c = connectionMaker.makeConnection();
        ps = c.prepareStatement("delete from users");
        ps.executeUpdate();
    } catch (ClassNotFoundException | SQLException e) {
        throw e;
    } finally {
        if( ps != null ){
            // ps.close() 메소드에서도 SQLException이 발생할 수 있으므로 try-catch로 잡아준다.
            try{
                ps.close();
            } catch (SQLException e){
                
            }
        }
        
        if(c != null){
            try{
                c.close();
            } catch (SQLException e){
                
            }
        }
    }

}
``` 
- JDBC 예외처리를 적용한 getCount()
```java 
// JDBC 예외처리를 적용한 getCount
public int getCount() throws SQLException, ClassNotFoundException {

    Connection c = null;
    PreparedStatement ps = null;
    ResultSet rs = null;

    try {
        c = connectionMaker.makeConnection();

        ps = c.prepareStatement("select count(*) from users");

        rs = ps.executeQuery();
        rs.next();

        int count = rs.getInt(1);
        return count;
    } catch (ClassNotFoundException | SQLException e) {
        throw e;
    } finally {

        // close()는 만들어지는 순서와 반대로 한다.
        if (rs != null) {
            try {
                rs.close();
            } catch (SQLException e) {

            }
        }

        if (ps != null) {
            // ps.close() 메소드에서도 SQLException이 발생할 수 있으므로 try-catch로 잡아준다.
            try {
                ps.close();
            } catch (SQLException e) {

            }
        }

        if (c != null) {
            try {
                c.close();
            } catch (SQLException e) {

            }
        }

    }   
}
```

## 분리와 재사용을 위한 디자인 패턴 적용
- 메소드 추출 : 문제점 - 분리시킨 메소드를 재사용하지 않는다. => 개선 - 템플릿 메소드
``` java 
// 변하는 부분을 메소드로 추출한 후의 deleteAll()
public void deleteAll() throws SQLException, ClassNotFoundException {
    Connection c = null;
    PreparedStatement ps = null;

    try {
        c = connectionMaker.makeConnection();
        ps = makeStatement(c);
        ps.executeUpdate();
    } catch (ClassNotFoundException | SQLException e) {
        throw e;
    } finally {
        if( ps != null ){
            // ps.close() 메소드에서도 SQLException이 발생할 수 있으므로 try-catch로 잡아준다.
            try{
                ps.close();
            } catch (SQLException e){

            }
        }
        if(c != null){
            try{
                c.close();
            } catch (SQLException e){

            }
        }
    }
}
private PreparedStatement makeStatement(Connection c) throws SQLException {
    PreparedStatement ps;
    ps = c.prepareStatement("delete from users");
    return ps;
}
```
- 템플릿 메소드 패턴 적용 : 상속을 통해 기능확장. 변하는 부분을 추상메소드로 둔다.
	- UserDao -> AbstractUserDao로 변경 (추상클래스)
``` java 
public abstract class AbstractUserDao {
	...
    abstract protected PreparedStatement makeStatement(Connection e) throws SQLException;
}
```
	- 추상 클래스를 상속받아서 기능 확장 -> try/catch/finally 는 고정 시킬 수 있다.
``` java 
public class UserDaoDeleteAll extends AbstractUserDao{

    protected PreparedStatement makeStatement(Connection c) throws SQLException {
        PreparedStatement ps = c.prepareStatement("delete from users");

        return ps;
    }
}
```
=> 템플릿 메소드의 단점
	- 상속을 통해 확장 필요 : 새로운 makeStatement 마다 클래스 필요
	- 전략 패턴을 이용해 상속을 통해 확장되는 단점 보완
- 전략 패턴 적용
	- 인터페이스를 통해 개방 폐쇄 원칙을 충실히 이행
	- 변하는 부분을 전략으로 만든 뒤 변하지 않는 부분(Context)에 적절히 적용한다.
	- PreparedStatement를 만드는 전략
``` java 
public interface StatementStrategy {
    PreparedStatement makePreparedStatement(Connection c) throws SQLException;
}
```
	- 인터페이스를 상속해 실제 전략을 만드는 클래스
``` java 
public class DeleteAllStatement implements StatementStrategy{
    @Override
    public PreparedStatement makePreparedStatement(Connection c) throws SQLException {
        PreparedStatement ps = c.prepareStatement("delete from users");
        
        return ps;
    }
}
```
	- 전략 패턴이 적용된 deleteAll() 메소드
``` java 
//전략패턴 이용
public void deleteAll() throws SQLException, ClassNotFoundException {
    Connection c = null;
    PreparedStatement ps = null;

    try {
        c = connectionMaker.makeConnection();
        StatementStrategy strategy = new DeleteAllStatement();
        ps = strategy.makePreparedStatement(c);
        
        ps.executeUpdate();
    } catch (ClassNotFoundException | SQLException e) {
        throw e;
    } finally {
        if( ps != null ){
            // ps.close() 메소드에서도 SQLException이 발생할 수 있으므로 try-catch로 잡아준다.
            try{
                ps.close();
            } catch (SQLException e){

            }
        }
        if(c != null){
            try{
                c.close();
            } catch (SQLException e){

            }
        }
    }
}
```
=> 컨텍스트 안에서 이미 구체적인 전략 클래스인 DeleteAllStatement를 사용하도록 고정하면 안된다.
	- DI 적용을 위한 클이언트/컨텍스트 분리
``` java 
// 클라이언트 책임을 담당할 deleteAll()
public void deleteAll() throws SQLException, ClassNotFoundException {
    StatementStrategy st = new DeleteAllStatement(); // 선정한 전략 클래스의 오브젝트 생성
    jdbcContextWithStatementStrategy(st); // 컨텍스트 호출. 전략 오브젝트 전달
}
// DI 적용을 위한 클라이언트/컨텍스트 분리
public void jdbcContextWithStatementStrategy(StatementStrategy stmt) throws SQLException, ClassNotFoundException {
    Connection c = null;
    PreparedStatement ps = null;

    try{
        c = connectionMaker.makeConnection();
        
        ps = stmt.makePreparedStatement(c);

        ps.executeUpdate();
    } catch (ClassNotFoundException | SQLException e) {
        throw e;
    } finally {
        if( ps != null ){
            // ps.close() 메소드에서도 SQLException이 발생할 수 있으므로 try-catch로 잡아준다.
            try{
                ps.close();
            } catch (SQLException e){

            }
        }
        if(c != null){
            try{
                c.close();
            } catch (SQLException e){

            }
        }
    }
}
```

## JDBC 전략 패턴의 최적화
- 전략 클래스의 추가 정보
	- AddStatement
``` java 
public class AddStatement implements StatementStrategy{
    
    User user;

    public AddStatement(User user) {
        this.user = user;
    }

    @Override
    public PreparedStatement makePreparedStatement(Connection c) throws SQLException {
        PreparedStatement ps = c.prepareStatement("insert into users(id, name, password) values(?,?,?)");
        ps.setString(1, user.getId());
        ps.setString(2, user.getName());
        ps.setString(3, user.getPassword());
        
        return ps;
    }
}
```
	- add() 메소드 수정
``` java 
// 전략 패턴 적용된 add
public void add(User user) throws ClassNotFoundException, SQLException{
    StatementStrategy st = new AddStatement(user);

    jdbcContextWithStatementStrategy(st);

 }
```
-> 2가지 불만
	1. DAO 메소드 마다 새로운 StatementStrategy 구현 클래스 생성 필요 -> 클래스 파일의 개수 증가
	- 로컬 클래스 이용
``` java 
// 로컬 클래스를 이용한 add - 전략마다 파일이 생성되는 것을 방지하기 위함
    public void add(final User user) throws ClassNotFoundException, SQLException {
        class AddStatement implements StatementStrategy{

            /*User user;

            public AddStatement(User user) {
                this.user = user;
            }*/

            @Override
            public PreparedStatement makePreparedStatement(Connection c) throws SQLException {
                PreparedStatement ps = c.prepareStatement("insert into users(id, name, password) values(?,?,?)");
                ps.setString(1, user.getId());
                ps.setString(2, user.getName());
                ps.setString(3, user.getPassword());

                return ps;
            }
        }

//        StatementStrategy st = new AddStatement(user);
        StatementStrategy st = new AddStatement(); // 파라미터로 user를 전달할 필요 없다.

        jdbcContextWithStatementStrategy(st);
    }
```
	 - 익명 내부 클래스로 전환
``` java 
// 익명 클래스를 이용한 add - 전략마다 파일이 생성되는 것을 방지하기 위함
public void add(final User user) throws ClassNotFoundException, SQLException {

    jdbcContextWithStatementStrategy(new StatementStrategy() {
        @Override
        public PreparedStatement makePreparedStatement(Connection c) throws SQLException {
            PreparedStatement ps = c.prepareStatement("insert into users(id, name, password) values(?,?,?)");
            ps.setString(1, user.getId());
            ps.setString(2, user.getName());
            ps.setString(3, user.getPassword());

            return ps;
        }
    }
    );
}

// 익명 내부 클래스를 이용한 deleteAll
public void deleteAll() throws ClassNotFoundException, SQLException{
    jdbcContextWithStatementStrategy(
            new StatementStrategy() {
                @Override
                public PreparedStatement makePreparedStatement(Connection c) throws SQLException {
                    return c.prepareStatement("delete from users");
                }
            }
    );
} 
```
	2. DAO 메소드에서 StatementStrategy에 전달할 User와 같은 부가적인 정보가 있는 경우, 오브젝트를 전달받는 생성자와 이를 저장할 인스턴스 변수를 만들어야 한다.
